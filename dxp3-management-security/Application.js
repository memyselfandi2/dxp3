/*
 * DXP3 - Digital Experience Platform 3
 *
 * PACKAGE
 * dxp3-management-security
 *
 * NAME
 * Application
 */
const packageName = 'dxp3-management-security';
const moduleName = 'Application';
const path = require('path');
const canonicalName = packageName + path.sep + moduleName;
/**
 * @module dxp3-management-security/Application
 */
const ApplicationOptions = require('./ApplicationOptions');
const cleanup = require('dxp3-cleanup');
const logging = require('dxp3-logging');
const rest = require('dxp3-microservice-rest');
const SecurityError = require('./SecurityError');
const util = require('dxp3-util');
const uuid = require('dxp3-uuid');

const logger = logging.getLogger(canonicalName);

class Application {

    constructor(args) {
        let self = this;
        // Make sure we gracefully shutdown when asked to do so.
        // We can register our own clean up function with the cleanupManager (configured in the package.json)
        cleanup.Manager.init();
        cleanup.Manager.addKillListener(self.cleanup);
        args = ApplicationOptions.parse(args);
        let securityServerArguments = {
            name: canonicalName,
            produces: 'dxp3-management-security',
            port: args.port
        }
        // We need an email service to send out registration emails.
        self.emailClient = new rest.RestClient({name: canonicalName, consumes: 'dxp3-email'})
        self.securityServer = new rest.RestServer(securityServerArguments);
        let securityImplClass = null;
        let securityImplClassLocation = './' + args.implementation + '/SecurityImpl';
        self.securityImpl = null;
        try {
            securityImplClass = require(securityImplClassLocation);
            self.securityImpl = new securityImplClass(args.securityImplArguments);
        } catch(exception) {
            logger.fatal('Unable to instantiate a SecurityImpl class of ' + args.implementation + '.');
            if(exception.code === 'MODULE_NOT_FOUND') {
                logger.fatal('Security implementation not found: ' + securityImplClassLocation);
                logger.fatal(exception);
            } else {
                logger.fatal(exception.message);
            }
            // This is serious enough to exit.
            process.exit(99);
        }
        /**
         * Every registration requires a code.
         */
        self.securityServer.addMethod('String generateCode([Number numberOfDigits])', function(numberOfDigits, response) {
            let result = self._generateCode(numberOfDigits);
console.log('generate code: ' + result);
            response.send(null, result);
        });
        /**
         * Used to register a new user. The code will typically be generated by calling our generatCode(...) method first.
         */
        self.securityServer.addMethod('Object registration(String emailAddress, String code)', function(emailAddress, code, response) {
            self.securityImpl.registration(emailAddress, code, function(err, registration) {
                if(err) {
                    return response.sendError(err.code);
                }
                self.emailClient.execute('send', 'versteegpatrick@gmail.com', emailAddress, 'Bizzns code', code, '<p>Your code:<strong>' + code + '</strong></p>');
                return response.send(null, registration);
            });
        });
        /**
         * Used to activate a registration (in essence activating an user).
         */
        self.securityServer.addMethod('Object activation(String registrationUUID, String code)', function(registrationUUID, code, response) {
            self.securityImpl.activation(registrationUUID, code, response);
        });
        /**
         * Used to authenticate (login) an user.
         */
        self.securityServer.addMethod('Object authentication(String emailAddress, String password)', function(emailAddress, password, response) {
            self.securityImpl.authentication(emailAddress, password, response);
        });
        self.securityServer.addMethod('Object createAccount(String userUUID, String accountName, [String description])', function(userUUID, accountName, description, response) {
            self.securityImpl.createAccount(userUUID, accountName, description, function(err, account) {
                if((err != undefined) && (err != null)) {
                    // If an account with the same name already exist there is no reason for alarm.
                    // If something else went wrong we'll log it as a warning.
                    if(err.code === SecurityError.CONFLICT.code) {
                        logger.info('createAccount(...): An account with name \'' + accountName + '\' already exists.');
                    } else {
                        logger.warn('createAccount(...): Unable to create a new account with name \'' + accountName + '\'. Error code: \'' + err + '\'.');
                    }
                    return response.sendError(err.code);
                }
                // Create a new 'Owners' usergroup with no parents.
                self.securityImpl.createUsergroup(account.uuid, userUUID, null, null, "Owners", null, function(err, usergroup) {
                    if((err != undefined) && (err != null)) {
                        if(err.code === SecurityError.CONFLICT.code) {
                            // Weird, but possible. Apparently the account dao implementation already created the required usergroup...
                            logger.info('on(\'create\',...): Account \'' + accountName + '\' already has an \'Owners\' usergroup.');
                        } else {
                            logger.warn('on(\'create\',...): Unable to create an \'Owners\' usergroup for account \'' + accountName + '\'. Error code: \'' + err + '\'.');
                        }
                    }
                    // We can not continue if there is no usergroup to add our user to...
                    if((usergroup === undefined) || (usergroup === null)) {
                        return;
                    }
                    self.securityImpl.addUserToUsergroup(account.uuid, userUUID, usergroup.uuid, userUUID, function(err, user) {
                        if((err != undefined) && (err != null)) {
                            logger.warn('on(\'create\',...): Unable to add an user to the \'Owners\' usergroup for account \'' + accountName + '\'. Error code: \'' + err + '\'.');
                            return;
                        }
                    });
                });
                // Create a new 'Administrators' usergroup with no parents.
                self.securityImpl.createUsergroup(account.uuid, userUUID, null, null, "Administrators", null, function(err, usergroup) {
                    if((err != undefined) && (err != null)) {
                        if(err.code === SecurityError.CONFLICT.code) {
                            // Weird, but possible. Apparently the account dao implementation already created the required usergroup...
                            logger.info('on(\'create\',...): Account \'' + accountName + '\' already has an \'Administrators\' usergroup.');
                        } else {
                            logger.warn('on(\'create\',...): Unable to create an \'Administrators\' usergroup for account \'' + accountName + '\'. Error code: \'' + err + '\'.');
                        }
                    }
                    // We can not continue if there is no usergroup to add our user to...
                    if((usergroup === undefined) || (usergroup === null)) {
                        return;
                    }
                    self.securityImpl.addUserToUsergroup(account.uuid, userUUID, usergroup.uuid, userUUID, function(err, user) {
                        if((err != undefined) && (err != null)) {
                            logger.warn('on(\'create\',...): Unable to add an user to the \'Administrators\' usergroup for account \'' + accountName + '\'. Error code: \'' + err + '\'.');
                            return;
                        }
                    });
                });
                self.securityImpl.addAccountToUser(account.uuid, userUUID, userUUID, account.uuid, function(err, user) {
                    if((err != undefined) && (err != null)) {
                        logger.warn('create(...): Unable to add new account \'' + account.uuid + '\' to user \'' + userUUID + '\'. Error code: \'' + err + '\'.');
                        return response.sendError(err.code);
                    }
                    return response.send(null, account);
                });
            });
        });
        self.securityServer.addMethod('Boolean signoff(String tokenUUID, String userUUID)', function(tokenUUID, userUUID, response) {
            self.securityImpl.signoff(tokenUUID, userUUID, response);
        });
        self.securityServer.addMethod('Object isAuthenticated(String tokenUUID, String userUUID)', function(tokenUUID, userUUID, response) {
            self.securityImpl.isAuthenticated(tokenUUID, userUUID, response);
        });
        self.securityServer.addMethod('Boolean isAuthorized(String tokenUUID, String userUUID, String accountUUID)', function(tokenUUID, userUUID, accountUUID, response) {
            self.securityImpl.isAuthorized(tokenUUID, userUUID, accountUUID, response);
        });
        self.securityServer.addMethod('Object accountSelection(String tokenUUID, String userUUID, String accountUUID)', function(tokenUUID, userUUID, accountUUID, response) {
            self.securityImpl.accountSelection(tokenUUID, userUUID, accountUUID, response);
        });
        self.securityServer.addMethod('Object getUserProfile(String tokenUUID, String userUUID)', function(tokenUUID, userUUID, response) {
            self.securityImpl.getUserProfile(tokenUUID, userUUID, response);
        });
        self.securityServer.addMethod('Object getUser(String tokenUUID, String userUUID)', function(tokenUUID, userUUID, response) {
            self.securityImpl.getUser(tokenUUID, userUUID, response);
        });
        self.securityServer.addMethod('Object getAccount(String tokenUUID, String userUUID, String accountUUID)', function(tokenUUID, userUUID, accountUUID, response) {
            self.securityImpl.getAccount(tokenUUID, userUUID, accountUUID, response);
        });
        self.securityServer.addMethod('Object updateUserProfile(String tokenUUID, String userUUID, String firstName, String lastName, [String description])', function(tokenUUID, userUUID, firstName, lastName, description, response) {
            self.securityImpl.updateUserProfile(tokenUUID, userUUID, firstName, lastName, description, response);
        });
        self.securityServer.addMethod('Boolean updatePassword(String tokenUUID, String userUUID, String password)', function(tokenUUID, userUUID, password, response) {
            self.securityImpl.updatePassword(tokenUUID, userUUID, password, response);
        });
        self.securityServer.addMethod('Boolean clearInterrupt(String tokenUUID, String userUUID)', function(tokenUUID, userUUID, response) {
            self.securityImpl.clearInterrupt(tokenUUID, userUUID, response);
        });
    }

    _generateCode(numberOfDigits) {
        let DEFAULT_NUMBER_OF_DIGITS = 6;
        let MAXIMUM_NUMBER_OF_DIGITS = 12;
        // Defensive programming...check input...
        if(numberOfDigits === undefined || numberOfDigits === null) {
            numberOfDigits = DEFAULT_NUMBER_OF_DIGITS;
        }
        if(typeof numberOfDigits != 'number') {
            if(typeof numberOfDigits === 'string') {
                try {
                    numberOfDigits = parseInt(numberOfDigits);
                } catch(exception) {
                    numberOfDigits = DEFAULT_NUMBER_OF_DIGITS;
                }
            } else {
                numberOfDigits = DEFAULT_NUMBER_OF_DIGITS;
            }
        }
        // To keep things realistic, we set a limits to the number of digits.
        if(numberOfDigits <= 0) {
            numberOfDigits = DEFAULT_NUMBER_OF_DIGITS;
        }
        if ( numberOfDigits > MAXIMUM_NUMBER_OF_DIGITS ) {
            numberOfDigits = MAXIMUM_NUMBER_OF_DIGITS;
        }
        // The maximum allowed number is the power of ten to the (number of digits + 1)
        // We remove the first digit when we return the result.
        let max = Math.pow(10, numberOfDigits + 1);
        // The minium allowed number is the power of ten to the (number of digits)
        // We remove the first digit when we return the result.
        let min = Math.pow(10, numberOfDigits);
        // Math.floor to make it an integer
        // Math.random to get a random number between 0 (inclusive) and 1 (not inclusive)
        // Max - Min to get the difference between the maximum allowed number and the minimum allowed number.
        // We add 1 to make the maximum inclusive.
        // Add Min to start at the minimum number.
        let number = Math.floor( Math.random() * (max - min + 1) ) + min;
        let result = ("" + number).substring(1);
        return result;
    }

    cleanup() {
        // Currently no cleanup required.
        // If cleanup is required in the future do it here.
        logger.info('cleanup finished.');
    }

    start() {
        let self = this;
        self.emailClient.start();
        self.securityServer.start();
    }

    static main() {
        try {
            let applicationOptions = ApplicationOptions.parseCommandLine();
            logging.setLevel(applicationOptions.logLevel);
            if(applicationOptions.help) {
                util.Help.print(this);
                return;
            }
            let application = new Application(applicationOptions);
            application.securityServer.on(rest.RestServerEvent.RUNNING, function() {
                console.log('To get help include the -help option:');
                console.log('node ./Application -help');
                console.log('');
                console.log(canonicalName + ' running at port ' + application.securityServer.port);
            });
            application.start();
        } catch(exception) {
            logger.fatal(exception);
            process.exit(99);
        }
    }
}
// Check if someone tried to run/execute this file.
if(util.Assert.isFileToExecute(canonicalName)) {
    Application.main();
    return;
}

module.exports = Application;